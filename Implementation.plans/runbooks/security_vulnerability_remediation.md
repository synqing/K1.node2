---
title: Security Vulnerability Remediation Runbook
status: draft
version: v1.0
owner: [Docs Maintainers]
reviewers: [Engineering Leads]
last_updated: 2025-10-28
next_review_due: 2026-01-26
tags: [plan]
related_docs: []
---
<!-- markdownlint-disable MD013 -->

# Security Vulnerability Remediation Runbook

**Author:** Claude Security Remediation Team
**Date:** 2025-10-27
**Status:** published
**Intent:** Step-by-step remediation guide for four critical security vulnerabilities with exact code changes, testing procedures, and verification steps.

---

## Overview

This runbook provides precise, atomic fixes for:
1. Memory exhaustion via unbounded HTTP body
2. Race condition in rate limiter
3. Memory leaks from handler allocation
4. Missing handler registration for WiFi link options GET

**Estimated effort:** 2-3 hours
**Testing effort:** 1-2 hours
**Risk level:** Low (fixes are scoped, non-breaking changes)

---

## FIX 1: Memory Exhaustion Attack - Content-Length Validation

### Problem

POST request bodies are allocated without size validation. An attacker can send `Content-Length: 2147483647` to exhaust ESP32 heap (8MB).

### Root Cause

**File:** `firmware/src/webserver_request_handler.h`
**Lines:** 182

```cpp
body->reserve(total);  // 'total' from HTTP header, no validation
```

### Solution

Add constant for maximum body size and validate before allocation.

### Implementation Steps

#### Step 1: Edit webserver_request_handler.h

**File:** `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/firmware/src/webserver_request_handler.h`

**Action:** Add constant after line 6

Find:
```cpp
#include "webserver_response_builders.h"
```

Insert after line 6:
```cpp
// Maximum POST body size (64KB) - prevents memory exhaustion attacks
static const size_t MAX_BODY_SIZE = 65536;
```

#### Step 2: Modify K1PostBodyHandler::operator()

**File:** `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/firmware/src/webserver_request_handler.h`
**Lines:** 175-196

Replace the entire function with security validation:

```cpp
void operator()(AsyncWebServerRequest* request, uint8_t* data, size_t len,
                size_t index, size_t total) {
    String *body = static_cast<String*>(request->_tempObject);

    // Initialize body buffer on first chunk
    if (index == 0) {
        // SECURITY FIX: Reject oversized requests before allocation
        if (total > MAX_BODY_SIZE) {
            // Prepare error response
            StaticJsonDocument<128> error_doc;
            error_doc["error"] = "payload_too_large";
            error_doc["max_size"] = MAX_BODY_SIZE;
            String error_str;
            serializeJson(error_doc, error_str);

            // Send 413 Payload Too Large
            auto *resp = request->beginResponse(413, "application/json", error_str);
            resp->addHeader("Content-Type", "application/json");
            resp->addHeader("X-Max-Body-Size", String(MAX_BODY_SIZE));
            request->send(resp);

            request->_tempObject = nullptr;
            return;
        }

        body = new String();
        body->reserve(total);
        request->_tempObject = body;
    }

    // Append data chunk
    body->concat(reinterpret_cast<const char*>(data), len);

    // Wait for more data if not complete
    if (index + len != total) {
        return;
    }

    // Body complete - invoke handler with rate limiting
    handler->handleWithRateLimit(request);
}
```

### Verification

#### Test 1: Normal POST request (should succeed)

```bash
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"brightness": 1.0}' \
  http://k1-reinvented.local/api/params

# Expected: 200 OK
```

#### Test 2: Oversized request (should be rejected)

```bash
curl -X POST \
  -H "Content-Length: 1073741824" \
  -H "Content-Type: application/json" \
  -d '{"brightness": 1.0}' \
  http://k1-reinvented.local/api/params \
  --max-time 2

# Expected: 413 Payload Too Large
# Device should remain responsive
```

#### Test 3: Device responsiveness after attack

```bash
# Send oversized request
(curl -X POST -H "Content-Length: 2147483647" -d '{}' \
  http://k1-reinvented.local/api/params &)

# Immediately check device is still responsive
sleep 0.5
curl http://k1-reinvented.local/api/test-connection

# Expected: 200 OK (device didn't crash)
```

### Rollback Procedure

If issues occur:
```bash
# Revert changes to webserver_request_handler.h
git checkout firmware/src/webserver_request_handler.h
```

---

## FIX 2: Race Condition in Rate Limiter - Synchronization

### Problem

Two concurrent requests can both bypass rate limiting due to TOCTOU race condition. No synchronization protects `control_windows[].last_ms` field.

### Root Cause

**File:** `firmware/src/webserver_rate_limiter.h`
**Lines:** 93, 102

```cpp
93:  if (w.last_ms != 0 && (now - w.last_ms) < w.window_ms) { return true; }
     // ↑ READS w.last_ms

102: w.last_ms = now;  // ← WRITES w.last_ms
     // No synchronization between read and write
```

### Solution

Use FreeRTOS spinlock (portMUX) to protect critical section.

### Implementation Steps

#### Step 1: Add FreeRTOS includes and mutex variable

**File:** `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/firmware/src/webserver_rate_limiter.h`

Find line 10-12:
```cpp
#pragma once

#include <cstring>
```

Replace with:
```cpp
#pragma once

#include <cstring>
#include <cstdint>
#include <freertos/FreeRTOS.h>
#include <freertos/portmacro.h>
```

#### Step 2: Add global spinlock after control_windows array

**File:** `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/firmware/src/webserver_rate_limiter.h`

Find lines 58-60:
```cpp
};

/**
```

Insert between lines 58 and 59:
```cpp
};

// Spinlock to protect concurrent access to control_windows
static portMUX_TYPE g_rate_limit_mux = portMUX_INITIALIZER_UNLOCKED;

/**
```

#### Step 3: Rewrite route_is_rate_limited() with synchronization

**File:** `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/firmware/src/webserver_rate_limiter.h`
**Lines:** 72-121

Replace entire function:

```cpp
/**
 * Check if a route is rate limited and update the rate limiter state
 *
 * Returns true if the route is currently rate limited (should reject with 429)
 * Returns false if the route is allowed (update last_ms and allow request)
 *
 * @param path Route path (e.g., "/api/params")
 * @param method HTTP method (ROUTE_GET or ROUTE_POST)
 * @param out_window_ms Optional: pointer to receive the rate limit window in ms
 * @param out_next_allowed_ms Optional: pointer to receive milliseconds until next allowed request
 * @return true if rate limited, false if allowed
 */
static bool route_is_rate_limited(
    const char* path,
    RouteMethod method,
    uint32_t* out_window_ms = nullptr,
    uint32_t* out_next_allowed_ms = nullptr
) {
    uint32_t now = millis();

    // SECURITY FIX: Protect shared state with spinlock
    taskENTER_CRITICAL(&g_rate_limit_mux);

    // Search for this route in the control_windows array
    for (size_t i = 0; i < sizeof(control_windows)/sizeof(control_windows[0]); ++i) {
        RouteWindow& w = control_windows[i];
        if (strcmp(w.path, path) == 0 && w.method == method) {
            // Found matching route configuration
            if (w.window_ms == 0) {
                // Rate limiting disabled for this route (0ms = no limit)
                if (out_window_ms) *out_window_ms = 0;
                if (out_next_allowed_ms) *out_next_allowed_ms = 0;
                taskEXIT_CRITICAL(&g_rate_limit_mux);
                return false;
            }

            // Check if within rate limit window
            bool is_rate_limited = false;
            if (w.last_ms != 0 && (now - w.last_ms) < w.window_ms) {
                // RATE LIMITED: too soon since last request
                is_rate_limited = true;
                if (out_window_ms) *out_window_ms = w.window_ms;
                uint32_t remaining = (w.last_ms + w.window_ms > now) ? (w.last_ms + w.window_ms - now) : 0;
                if (out_next_allowed_ms) *out_next_allowed_ms = remaining;
            } else {
                // Not limited; update last_ms and allow this request
                // Now protected by spinlock - atomic update
                w.last_ms = now;
                if (out_window_ms) *out_window_ms = w.window_ms;
                if (out_next_allowed_ms) *out_next_allowed_ms = 0;
            }

            taskEXIT_CRITICAL(&g_rate_limit_mux);
            return is_rate_limited;
        }
    }

    // Route not found in control_windows array
    // Default: GET requests are unlimited; unknown POST routes treated as unlimited unless configured
    if (method == ROUTE_GET) {
        if (out_window_ms) *out_window_ms = 0;
        if (out_next_allowed_ms) *out_next_allowed_ms = 0;
        taskEXIT_CRITICAL(&g_rate_limit_mux);
        return false;
    }

    // Unknown POST route - no rate limiting by default
    if (out_window_ms) *out_window_ms = 0;
    if (out_next_allowed_ms) *out_next_allowed_ms = 0;
    taskEXIT_CRITICAL(&g_rate_limit_mux);
    return false;
}
```

### Verification

#### Test 1: Verify rate limiting still works

```bash
# First request should succeed
curl -X POST -H "Content-Type: application/json" -d '{"brightness": 1.0}' \
  http://k1-reinvented.local/api/params

# Second request within 300ms should be rate limited
curl -X POST -H "Content-Type: application/json" -d '{"brightness": 0.5}' \
  http://k1-reinvented.local/api/params

# Expected second response: 429 Too Many Requests
```

#### Test 2: Concurrent requests are properly serialized

```python
import concurrent.futures
import requests
import time

def test_rate_limit_with_concurrent_requests():
    """Send 8 concurrent requests - only first should succeed"""
    results = []

    def send_request():
        try:
            r = requests.post(
                'http://k1-reinvented.local/api/params',
                json={'brightness': 0.5},
                timeout=2
            )
            return r.status_code
        except:
            return None

    # Send 8 concurrent requests
    with concurrent.futures.ThreadPoolExecutor(max_workers=8) as executor:
        futures = [executor.submit(send_request) for _ in range(8)]
        results = [f.result() for f in concurrent.futures.as_completed(futures)]

    allowed_count = sum(1 for r in results if r == 200)
    rate_limited_count = sum(1 for r in results if r == 429)

    print(f"Allowed: {allowed_count} (expected: 1)")
    print(f"Rate limited: {rate_limited_count} (expected: 7)")

    assert allowed_count == 1, f"Expected 1 allowed, got {allowed_count}"
    assert rate_limited_count >= 6, f"Expected at least 6 rate limited, got {rate_limited_count}"
    print("[✓] Test passed: Race condition fixed")

test_rate_limit_with_concurrent_requests()
```

#### Test 3: ROUTE_RESET cannot be triggered twice rapidly

```bash
# Attempt to trigger reset twice within 1000ms window
start_time=$(date +%s%N)

curl -X POST http://k1-reinvented.local/api/reset &
PID1=$!

curl -X POST http://k1-reinvented.local/api/reset &
PID2=$!

wait $PID1 $PID2

end_time=$(date +%s%N)
elapsed_ms=$(( (end_time - start_time) / 1000000 ))

# Device should have rebooted after first request
# Second request should have been rate limited

echo "Test completed in ${elapsed_ms}ms"
echo "Expected: Device reset once, second request was rate limited"
```

### Rollback Procedure

```bash
git checkout firmware/src/webserver_rate_limiter.h
```

---

## FIX 3: Memory Leaks - Handler Cleanup (Optional Best Practice)

### Problem

Handler objects allocated with `new` but never `delete`. For current static design, acceptable. But violates RAII pattern.

### Root Cause

**File:** `firmware/src/webserver.cpp`
**Lines:** 403-420

Handler allocations without corresponding cleanup.

### Solution

Implement optional cleanup (not critical, but prevents future bugs). Two approaches:

#### Approach A: Simple Array-Based Cleanup (Recommended for simplicity)

**File:** `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/firmware/src/webserver.cpp`

##### Step 1: Add global handler array at file scope

Find line 25-29:
```cpp
// Global async web server on port 80
static AsyncWebServer server(80);

// Global WebSocket server at /ws endpoint
static AsyncWebSocket ws("/ws");
```

Insert after line 29:
```cpp
// Handler pointers for lifetime management
static K1RequestHandler* g_handlers[16];
static size_t g_handler_count = 0;
```

##### Step 2: Create helper function to register handlers

Find line 206-229 in webserver_request_handler.h (registerGetHandler and registerPostHandler)

Add after webserver.cpp line 30:
```cpp
// Helper: Register handler and track for cleanup
inline void register_get_handler_tracked(AsyncWebServer& server, const char* path, K1RequestHandler* handler) {
    if (g_handler_count < 16) {
        g_handlers[g_handler_count++] = handler;
        registerGetHandler(server, path, handler);
    }
}

inline void register_post_handler_tracked(AsyncWebServer& server, const char* path, K1RequestHandler* handler) {
    if (g_handler_count < 16) {
        g_handlers[g_handler_count++] = handler;
        registerPostHandler(server, path, handler);
    }
}
```

##### Step 3: Update all handler registrations in init_webserver()

Replace each `registerGetHandler` and `registerPostHandler` call with `register_get_handler_tracked` and `register_post_handler_tracked`.

For example, line 403:
```cpp
// Before:
registerGetHandler(server, ROUTE_PATTERNS, new GetPatternsHandler());

// After:
register_get_handler_tracked(server, ROUTE_PATTERNS, new GetPatternsHandler());
```

Repeat for all 14 handler registrations (lines 403-420).

##### Step 4: Add cleanup function

Add before line 401 (before init_webserver()):
```cpp
// Cleanup handlers (called on shutdown or reboot)
void cleanup_webserver() {
    for (size_t i = 0; i < g_handler_count; ++i) {
        if (g_handlers[i]) {
            delete g_handlers[i];
            g_handlers[i] = nullptr;
        }
    }
    g_handler_count = 0;
}
```

#### Approach B: Modern C++ with std::unique_ptr (If C++17 available)

Requires checking that `std::unique_ptr` is available in the project's ESP-IDF configuration.

```cpp
#include <memory>
#include <vector>

static std::vector<std::unique_ptr<K1RequestHandler>> g_handlers;

void init_webserver() {
    // Create handlers with automatic cleanup on scope exit
    g_handlers.push_back(std::make_unique<GetPatternsHandler>());
    registerGetHandler(server, ROUTE_PATTERNS, g_handlers.back().get());

    g_handlers.push_back(std::make_unique<GetParamsHandler>());
    registerGetHandler(server, ROUTE_PARAMS, g_handlers.back().get());

    // ... rest of handlers

    // Cleanup happens automatically when g_handlers vector is destroyed
}
```

### Verification

#### Test 1: Application starts and runs normally

```bash
# Flash firmware
platformio run -e esp32-s3-devkitc-1 -t upload

# Monitor for errors
platformio device monitor

# Expected: No crashes, all endpoints responsive
```

#### Test 2: (If cleanup function added) Device shuts down cleanly

```cpp
// In shutdown sequence (if implemented):
cleanup_webserver();

// Verify no dangling pointers
// Use memory leak detector if available
```

### Recommendation

**Priority:** MEDIUM
**Effort:** 1-2 hours
**Benefit:** Prevents future dynamic handler bugs, improves code clarity
**Impact:** None (handlers are still singletons for the fix)

---

## FIX 4: Missing Handler Registration - WiFi Link Options GET

### Problem

GET /api/wifi/link-options handler was not refactored into standard handler pattern. Uses raw `server.on()` instead of `registerGetHandler()`.

### Root Cause

**File:** `firmware/src/webserver.cpp`
**Lines:** 489-510

Handler manually implemented instead of using handler pattern.

### Solution

Create GetWifiLinkOptionsHandler class and use standard registration.

### Implementation Steps

#### Step 1: Create handler class

**File:** `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/firmware/src/webserver.cpp`

Find the other GET handlers (around line 268):

```cpp
// GET /api/audio-config - Get audio configuration (microphone gain)
class GetAudioConfigHandler : public K1RequestHandler {
```

Add before GetAudioConfigHandler:

```cpp
// GET /api/wifi/link-options - Get current WiFi link options
class GetWifiLinkOptionsHandler : public K1RequestHandler {
public:
    GetWifiLinkOptionsHandler() : K1RequestHandler(ROUTE_WIFI_LINK_OPTIONS, ROUTE_GET) {}
    void handle(RequestContext& ctx) override {
        WifiLinkOptions opts;
        wifi_monitor_get_link_options(opts);
        StaticJsonDocument<128> doc;
        doc["force_bg_only"] = opts.force_bg_only;
        doc["force_ht20"] = opts.force_ht20;
        String output;
        serializeJson(doc, output);
        ctx.sendJson(200, output);
    }
};

```

#### Step 2: Register handler in init_webserver()

**File:** `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/firmware/src/webserver.cpp`

Find line 419-420:
```cpp
    // Register remaining GET handlers
    registerGetHandler(server, ROUTE_AUDIO_CONFIG, new GetAudioConfigHandler());
    registerGetHandler(server, ROUTE_CONFIG_BACKUP, new GetConfigBackupHandler());
```

Add after line 420:
```cpp
    registerGetHandler(server, ROUTE_WIFI_LINK_OPTIONS, new GetWifiLinkOptionsHandler());
```

#### Step 3: Remove old raw handler implementation

**File:** `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/firmware/src/webserver.cpp`

Find and DELETE lines 489-510:
```cpp
    // GET /api/wifi/link-options - Get current WiFi link options
    server.on(ROUTE_WIFI_LINK_OPTIONS, HTTP_GET, [](AsyncWebServerRequest *request) {
        // ... entire handler body ...
    });
```

### Verification

#### Test 1: GET /api/wifi/link-options still works

```bash
curl http://k1-reinvented.local/api/wifi/link-options

# Expected: 200 OK with JSON response
# { "force_bg_only": false, "force_ht20": true }
```

#### Test 2: Rate limiting works correctly

```bash
# First request succeeds
curl http://k1-reinvented.local/api/wifi/link-options

# Immediate second request is rate limited (500ms window)
curl http://k1-reinvented.local/api/wifi/link-options

# Expected second response: 429 Too Many Requests
```

#### Test 3: CORS headers present

```bash
curl -i http://k1-reinvented.local/api/wifi/link-options

# Expected: Response includes CORS headers
# Access-Control-Allow-Origin: *
# Access-Control-Allow-Methods: GET, POST, OPTIONS
```

---

## Final Verification Checklist

Before considering remediation complete:

- [ ] **FIX 1: Memory Exhaustion**
  - [ ] MAX_BODY_SIZE constant added
  - [ ] Content-Length validation implemented
  - [ ] 413 error response on oversized body
  - [ ] Normal requests still work
  - [ ] Attack requests rejected without crashing device

- [ ] **FIX 2: Race Condition**
  - [ ] portMUX includes added
  - [ ] g_rate_limit_mux spinlock declared
  - [ ] taskENTER_CRITICAL/EXIT_CRITICAL wraps critical section
  - [ ] Rate limiting still rejects rapid requests
  - [ ] Concurrent requests properly serialized

- [ ] **FIX 3: Memory Leaks** (Optional)
  - [ ] Handler tracking array added (if Approach A)
  - [ ] OR unique_ptr vector added (if Approach B)
  - [ ] Application starts without errors
  - [ ] Cleanup function works (if added)

- [ ] **FIX 4: Missing Handler**
  - [ ] GetWifiLinkOptionsHandler class created
  - [ ] Handler registered via registerGetHandler()
  - [ ] Raw server.on() code removed
  - [ ] GET /api/wifi/link-options still works
  - [ ] Rate limiting works for this endpoint
  - [ ] CORS headers present

### Compilation Verification

```bash
# Navigate to project root
cd /Users/spectrasynq/Workspace_Management/Software/K1.reinvented

# Build firmware
platformio run -e esp32-s3-devkitc-1

# Expected: Build successful with 0 errors, 0 warnings
# Check output for:
# "BUILD SUCCESSFUL" or "Compiling .pio/build/..."
```

### Runtime Verification

```bash
# Flash to device
platformio run -e esp32-s3-devkitc-1 -t upload

# Monitor startup
platformio device monitor

# Expected output:
# "Web server started on port 80"
# "WebSocket server available at /ws"
# No error messages
```

### Security Testing

```bash
# Create test script: test_security_fixes.sh
cat > test_security_fixes.sh << 'EOF'
#!/bin/bash

TARGET="k1-reinvented.local"

echo "[*] Testing Security Fixes"
echo ""

# Test 1: Memory exhaustion attack should fail
echo "[1] Memory exhaustion attack (should be rejected)..."
timeout 2 curl -X POST -H "Content-Length: 2147483647" \
  -d '{"brightness":1.0}' http://${TARGET}/api/params 2>/dev/null || echo "Rejected as expected"

# Test 2: Normal request should work after attack attempt
echo "[2] Device still responsive after attack..."
curl http://${TARGET}/api/test-connection | jq .

# Test 3: Rate limit enforcement
echo "[3] Rate limit enforcement..."
curl -s http://${TARGET}/api/params | head -c 100
sleep 0.1
curl -s http://${TARGET}/api/params | head -c 100

# Test 4: WiFi link options endpoint
echo "[4] WiFi link options endpoint..."
curl http://${TARGET}/api/wifi/link-options | jq .

echo ""
echo "[✓] All security tests completed"
EOF

chmod +x test_security_fixes.sh
./test_security_fixes.sh
```

---

## Documentation Updates

### Update CHANGELOG.md

Add entry documenting security fixes:

```markdown
## [2.1.0] - 2025-10-27

### Security Fixes
- Fixed critical memory exhaustion vulnerability (CWE-400): Added Content-Length validation in POST body handler with 64KB maximum
- Fixed critical race condition vulnerability (CWE-362): Added FreeRTOS spinlock protection to rate limiter critical section
- Fixed high memory leak vulnerability (CWE-401): Handler cleanup tracking implemented [OPTIONAL]
- Fixed code quality issue: Refactored WiFi link options GET handler into standard pattern

### Verification
- All four vulnerabilities confirmed and fixed
- Security validation report: docs/reports/security_vulnerability_validation_report.md
- Technical forensics: docs/analysis/webserver_security_forensics.md
```

### Update API Documentation

Add to API docs about body size limit:

```markdown
### POST Request Limitations

All POST endpoints enforce a maximum request body size of **64KB** (65,536 bytes).

Requests exceeding this limit will receive a `413 Payload Too Large` error response:

```json
{
  "error": "payload_too_large",
  "max_size": 65536
}
```

This limit prevents memory exhaustion attacks on embedded hardware with limited heap.
```

---

## Rollback Procedures

If any fix causes unexpected issues:

### Complete Rollback

```bash
git revert HEAD~3  # Revert last 3 commits (if all fixes applied as one commit)
# OR
git checkout <commit-hash>  # Revert to known good version
```

### Individual Fix Rollback

```bash
# Revert just FIX 1
git checkout firmware/src/webserver_request_handler.h

# Revert just FIX 2
git checkout firmware/src/webserver_rate_limiter.h

# Revert just FIX 3
git checkout firmware/src/webserver.cpp

# Revert just FIX 4
git checkout firmware/src/webserver.cpp
```

---

## Post-Deployment Monitoring

After deploying fixes:

### Monitor API Response Times

```bash
# Check that rate limiting doesn't introduce latency
while true; do
  curl -w "Response time: %{time_total}s\n" -o /dev/null -s http://k1-reinvented.local/api/params
  sleep 1
done

# Expected: <100ms response time
```

### Monitor Heap Usage

```bash
# Check device performance metrics
curl http://k1-reinvented.local/api/device/performance | jq .memory_percent

# Expected: <70% memory usage (leaves headroom for operations)
```

### Log Analysis

```bash
# Monitor serial output for errors
platformio device monitor

# Search for:
# - "ERROR" messages
# - "rate_limit" messages
# - "memory" messages
```

---

## Sign-Off Checklist

When remediation is complete and verified:

- [ ] All 4 fixes implemented
- [ ] Code compiles without errors or warnings
- [ ] Device starts successfully
- [ ] Manual tests pass (see Verification sections)
- [ ] Security tests pass (attack vectors now rejected)
- [ ] Rate limiting functional
- [ ] API endpoints responsive
- [ ] Documentation updated
- [ ] Changelog entry added
- [ ] Code review completed
- [ ] Ready for deployment

---

## Timeline

| Phase | Task | Duration | Owner |
|---|---|---|---|
| 1 | Implement FIX 1 (Memory exhaustion) | 30 min | Engineer |
| 2 | Implement FIX 2 (Race condition) | 45 min | Engineer |
| 3 | Implement FIX 3 (Memory leaks - optional) | 20 min | Engineer |
| 4 | Implement FIX 4 (Missing handler) | 20 min | Engineer |
| 5 | Compile and initial testing | 20 min | Engineer |
| 6 | Security verification tests | 30 min | QA/Security |
| 7 | Documentation and changelog | 15 min | Engineer |
| **Total** | | **2.5-3 hours** | |

---

## References

- Security validation report: `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/docs/reports/security_vulnerability_validation_report.md`
- Technical forensics: `/Users/spectrasynq/Workspace_Management/Software/K1.reinvented/docs/analysis/webserver_security_forensics.md`
- FreeRTOS Critical Sections: https://www.freertos.org/taskENTER_CRITICAL.html
- ESP-IDF Documentation: https://docs.espressif.com/projects/esp-idf/


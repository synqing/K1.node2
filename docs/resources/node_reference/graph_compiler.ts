// K1.reinvented Node Graph Compiler
// Compiles JSON node graphs to zero-overhead C++ code

interface Node {
    id: number;
    type: string;
    params?: Record<string, any>;
    inputs?: number[];  // IDs of input nodes
}

interface Edge {
    from: number;
    to: number;
    toPort?: number;  // Which input port (0, 1, 2, etc)
}

interface NodeGraph {
    nodes: Node[];
    edges: Edge[];
}

class GraphCompiler {
    private nodeMap: Map<number, Node> = new Map();
    private nodeCode: Map<number, string> = new Map();
    private dependencies: Map<number, number[]> = new Map();
    
    compile(graph: NodeGraph): string {
        this.buildNodeMap(graph);
        this.buildDependencyGraph(graph);
        const sorted = this.topologicalSort();
        
        return this.generateCpp(sorted);
    }
    
    private buildNodeMap(graph: NodeGraph) {
        this.nodeMap.clear();
        graph.nodes.forEach(node => {
            this.nodeMap.set(node.id, node);
        });
    }
    
    private buildDependencyGraph(graph: NodeGraph) {
        this.dependencies.clear();
        
        // Initialize all nodes with empty dependency lists
        graph.nodes.forEach(node => {
            this.dependencies.set(node.id, []);
        });
        
        // Build dependency lists from edges
        graph.edges.forEach(edge => {
            const deps = this.dependencies.get(edge.to) || [];
            deps.push(edge.from);
            this.dependencies.set(edge.to, deps);
        });
    }
    
    private topologicalSort(): number[] {
        const visited = new Set<number>();
        const sorted: number[] = [];
        
        const visit = (nodeId: number) => {
            if (visited.has(nodeId)) return;
            visited.add(nodeId);
            
            const deps = this.dependencies.get(nodeId) || [];
            deps.forEach(dep => visit(dep));
            
            sorted.push(nodeId);
        };
        
        this.nodeMap.forEach((_, id) => visit(id));
        return sorted;
    }
    
    private generateCpp(sortedNodes: number[]): string {
        const header = this.generateHeader();
        const effect = this.generateEffect(sortedNodes);
        const footer = this.generateFooter();
        
        return `${header}\n${effect}\n${footer}`;
    }
    
    private generateHeader(): string {
        return `// Auto-generated by K1.reinvented Node Compiler
// This code has ZERO runtime overhead - everything is inlined
#pragma once

#include "types.h"
#include "led_driver.h"
#include <math.h>

namespace generated {

// Effect function - compiles to tight machine code
inline void render_effect(CRGBF* leds, int count, float time) {
    // All node computations inline into this loop
    for (int i = 0; i < count; i++) {`;
    }
    
    private generateEffect(sortedNodes: number[]): string {
        const lines: string[] = [];
        
        // Generate code for each node in dependency order
        sortedNodes.forEach(nodeId => {
            const node = this.nodeMap.get(nodeId);
            if (!node) return;
            
            const code = this.nodeToCode(node);
            lines.push(`        ${code}`);
            this.nodeCode.set(nodeId, `v${nodeId}`);
        });
        
        // Find output node and assign to LED
        const outputNode = Array.from(this.nodeMap.values())
            .find(n => n.type === 'output');
        
        if (outputNode) {
            const deps = this.dependencies.get(outputNode.id) || [];
            if (deps.length > 0) {
                lines.push(`        leds[i] = v${deps[0]};`);
            }
        }
        
        return lines.join('\n');
    }
    
    private generateFooter(): string {
        return `    }
}

} // namespace generated`;
    }
    
    private nodeToCode(node: Node): string {
        const deps = this.dependencies.get(node.id) || [];
        
        switch (node.type) {
            case 'position':
                return `float v${node.id} = float(i) / float(count);`;
            
            case 'time':
                return `float v${node.id} = time;`;
            
            case 'index':
                return `int v${node.id} = i;`;
            
            case 'literal':
                return `float v${node.id} = ${node.params?.value || 0}f;`;
            
            case 'add':
                if (deps.length >= 2) {
                    return `float v${node.id} = v${deps[0]} + v${deps[1]};`;
                }
                break;
            
            case 'multiply':
                if (deps.length >= 2) {
                    return `float v${node.id} = v${deps[0]} * v${deps[1]};`;
                }
                break;
            
            case 'sin':
                if (deps.length >= 1) {
                    // Use FastLED's sin8 for performance
                    return `float v${node.id} = sin8(uint8_t(v${deps[0]} * 255.0f)) / 255.0f;`;
                }
                break;
            
            case 'cos':
                if (deps.length >= 1) {
                    return `float v${node.id} = cos8(uint8_t(v${deps[0]} * 255.0f)) / 255.0f;`;
                }
                break;
            
            case 'scale':
                if (deps.length >= 1) {
                    const factor = node.params?.factor || 1.0;
                    return `float v${node.id} = v${deps[0]} * ${factor}f;`;
                }
                break;
            
            case 'clamp':
                if (deps.length >= 1) {
                    const min = node.params?.min || 0.0;
                    const max = node.params?.max || 1.0;
                    return `float v${node.id} = fmax(${min}f, fmin(${max}f, v${deps[0]}));`;
                }
                break;
            
            case 'hsv_to_rgb':
                if (deps.length >= 3) {
                    return `CRGBF v${node.id} = hsv_to_rgb(v${deps[0]}, v${deps[1]}, v${deps[2]});`;
                } else if (deps.length >= 1) {
                    // Use hue only, max saturation and value
                    return `CRGBF v${node.id} = hsv_to_rgb(v${deps[0]}, 1.0f, 1.0f);`;
                }
                break;
            
            case 'palette':
                if (deps.length >= 1) {
                    const colors = node.params?.colors || ["#000000", "#FFFFFF"];
                    return this.generatePaletteCode(node.id, deps[0], colors);
                }
                break;
            
            case 'gradient':
                if (deps.length >= 1) {
                    const positions = node.params?.positions || [0, 1];
                    const colors = node.params?.colors || ["#000000", "#FFFFFF"];
                    return this.generateGradientCode(node.id, deps[0], positions, colors);
                }
                break;
            
            case 'noise':
                if (deps.length >= 1) {
                    const scale = node.params?.scale || 1.0;
                    const speed = node.params?.speed || 1.0;
                    return `float v${node.id} = inoise8(v${deps[0]} * ${scale}f * 255.0f, time * ${speed}f * 255.0f) / 255.0f;`;
                }
                break;
            
            case 'beat':
                const bpm = node.params?.bpm || 120;
                return `float v${node.id} = beat8(${bpm}) / 255.0f;`;
            
            case 'beatsin':
                const bpmSin = node.params?.bpm || 60;
                const min = node.params?.min || 0;
                const max = node.params?.max || 255;
                return `float v${node.id} = beatsin8(${bpmSin}, ${min}, ${max}) / 255.0f;`;
            
            case 'output':
                // Output node doesn't generate code itself
                return '';
        }
        
        return `float v${node.id} = 0.0f; // Unknown node type: ${node.type}`;
    }
    
    private generatePaletteCode(nodeId: number, inputId: number, colors: string[]): string {
        const lines: string[] = [];
        
        // Convert hex colors to RGB
        const rgbColors = colors.map(this.hexToRgb);
        
        // Generate palette interpolation code
        lines.push(`CRGBF v${nodeId}; {`);
        lines.push(`    float pos = v${inputId} * ${colors.length - 1}f;`);
        lines.push(`    int idx = int(pos);`);
        lines.push(`    float fract = pos - float(idx);`);
        lines.push(`    `);
        
        // Generate color array
        lines.push(`    const CRGBF palette[] = {`);
        rgbColors.forEach((rgb, i) => {
            const comma = i < rgbColors.length - 1 ? ',' : '';
            lines.push(`        CRGBF(${rgb.r}f, ${rgb.g}f, ${rgb.b}f)${comma}`);
        });
        lines.push(`    };`);
        lines.push(`    `);
        
        // Interpolation logic
        lines.push(`    if (idx >= ${colors.length - 1}) {`);
        lines.push(`        v${nodeId} = palette[${colors.length - 1}];`);
        lines.push(`    } else {`);
        lines.push(`        const CRGBF& c1 = palette[idx];`);
        lines.push(`        const CRGBF& c2 = palette[idx + 1];`);
        lines.push(`        v${nodeId} = CRGBF(`);
        lines.push(`            c1.r + (c2.r - c1.r) * fract,`);
        lines.push(`            c1.g + (c2.g - c1.g) * fract,`);
        lines.push(`            c1.b + (c2.b - c1.b) * fract`);
        lines.push(`        );`);
        lines.push(`    }`);
        lines.push(`}`);
        
        return lines.join('\n        ');
    }
    
    private generateGradientCode(nodeId: number, inputId: number, positions: number[], colors: string[]): string {
        // Similar to palette but with custom position stops
        const lines: string[] = [];
        const rgbColors = colors.map(this.hexToRgb);
        
        lines.push(`CRGBF v${nodeId}; {`);
        lines.push(`    float t = v${inputId};`);
        
        // Find which segment we're in
        for (let i = 0; i < positions.length - 1; i++) {
            const p1 = positions[i];
            const p2 = positions[i + 1];
            const condition = i === 0 ? `if` : `else if`;
            
            lines.push(`    ${condition} (t >= ${p1}f && t <= ${p2}f) {`);
            lines.push(`        float local_t = (t - ${p1}f) / ${p2 - p1}f;`);
            lines.push(`        CRGBF c1(${rgbColors[i].r}f, ${rgbColors[i].g}f, ${rgbColors[i].b}f);`);
            lines.push(`        CRGBF c2(${rgbColors[i+1].r}f, ${rgbColors[i+1].g}f, ${rgbColors[i+1].b}f);`);
            lines.push(`        v${nodeId} = CRGBF(`);
            lines.push(`            c1.r + (c2.r - c1.r) * local_t,`);
            lines.push(`            c1.g + (c2.g - c1.g) * local_t,`);
            lines.push(`            c1.b + (c2.b - c1.b) * local_t`);
            lines.push(`        );`);
            lines.push(`    }`);
        }
        
        // Handle edge cases
        lines.push(`    else if (t < ${positions[0]}f) {`);
        lines.push(`        v${nodeId} = CRGBF(${rgbColors[0].r}f, ${rgbColors[0].g}f, ${rgbColors[0].b}f);`);
        lines.push(`    } else {`);
        const last = rgbColors[rgbColors.length - 1];
        lines.push(`        v${nodeId} = CRGBF(${last.r}f, ${last.g}f, ${last.b}f);`);
        lines.push(`    }`);
        lines.push(`}`);
        
        return lines.join('\n        ');
    }
    
    private hexToRgb(hex: string): {r: number, g: number, b: number} {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16) / 255,
            g: parseInt(result[2], 16) / 255,
            b: parseInt(result[3], 16) / 255
        } : {r: 0, g: 0, b: 0};
    }
}

// Example: Compile the Departure pattern
const departureGraph: NodeGraph = {
    nodes: [
        { id: 0, type: "position" },
        { id: 1, type: "time" },
        { id: 2, type: "scale", params: { factor: 2.0 } },
        { id: 3, type: "sin" },
        { id: 4, type: "scale", params: { factor: 0.1 } },
        { id: 5, type: "add" },
        { 
            id: 6, 
            type: "palette",
            params: {
                colors: ["#000000", "#FF6B35", "#FFFFFF", "#00FF00"]
            }
        },
        { id: 7, type: "output" }
    ],
    edges: [
        { from: 0, to: 5, toPort: 0 },      // position -> add
        { from: 1, to: 2 },                 // time -> scale
        { from: 2, to: 3 },                 // scale -> sin
        { from: 3, to: 4 },                 // sin -> scale
        { from: 4, to: 5, toPort: 1 },      // scale -> add
        { from: 5, to: 6 },                 // add -> palette
        { from: 6, to: 7 }                  // palette -> output
    ]
};

// Usage
const compiler = new GraphCompiler();
const cppCode = compiler.compile(departureGraph);
console.log(cppCode);

export { GraphCompiler, NodeGraph, Node, Edge };

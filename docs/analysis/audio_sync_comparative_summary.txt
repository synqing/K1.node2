================================================================================
AUDIO/VISUAL SYNCHRONIZATION: COMPARATIVE REFERENCE TABLE
================================================================================
Analysis Date: 2025-10-28 | Status: FORENSIC EXAMINATION | Confidence: HIGH

================================================================================
1. THREADING & EXECUTION MODEL
================================================================================

Sensory Bridge
  Threading:        Single-core (Core 0 only)
  Location:         main.cpp:150, main.cpp:185
  Audio/Video:      Sequential (same thread)
  Synchronization:  Atomic (no locks needed)

ESv1.2 (Emotiscope v1.2)
  Threading:        Dual-core explicit (Core 0=GPU, Core 1=Audio)
  Location:         EMOTISCOPE_FIRMWARE.ino:139
  Audio/Video:      Parallel (independent cores)
  Synchronization:  Volatile flags + independent rates

ESv2.0 (Emotiscope v2.0)
  Threading:        Dual-core explicit (Core 0=GPU, Core 1=Audio)
  Location:         Emotiscope.c:165, cpu_core.h:84
  Audio/Video:      Parallel (independent cores)
  Synchronization:  Implicit (no explicit flags in excerpt)

K1.reinvented
  Threading:        Single-core (Core 0 only)
  Location:         main.cpp:238-249
  Audio/Video:      Sequential (conditionally gated)
  Synchronization:  Atomic (no locks needed, ring buffer stub)

================================================================================
2. AUDIO ACQUISITION PARAMETERS
================================================================================

                   Sensory Bridge   ESv1.2   ESv2.0   K1.reinvented
Sample Rate        16,000 Hz       25,600   12,800   16,000 Hz
                   (c.h:10)        Hz       Hz       (m.h:27)
                                   (m.h:24) (m.h:20)

Chunk Size         128 samples     128*2    128      128 samples
                   (i2s_a.h:22)    samples  samples  (m.h:26)
                                   (m.h:154)(m.h:21)

Chunk Duration     8 ms            5 ms     10 ms    8 ms
(calculated)       @ 16 kHz        @ 25.6   @ 12.8   @ 16 kHz
                                   kHz      kHz

I2S Read Timeout   portMAX_DELAY   portMAX_ portMAX_ portMAX_DELAY
                   (i2s_a.h:65)    DELAY    DELAY    (m.h:97)
                                   (m.h:159)(m.h:96)

Read Location      Main loop       Core 1   Core 1   Main loop
                   (sequential)    (CPU)    (CPU)    (sequential)

Blocking Effect    None            None     None     None
Reason             DMA prebuffered DMA pre- DMA pre- DMA
                   + single-thread buffered buffered prebuffered
                                   + diff   + diff   + single-
                                   core     core     thread

Error Handling     None visible    None     None     Yes: check
                                                     return code
                                                     (m.h:98-105)

================================================================================
3. RENDERING LOOP PARAMETERS
================================================================================

                   Sensory Bridge   ESv1.2      ESv2.0      K1.reinvented
Main Loop Func     main_loop_core0 loop_gpu    loop_gpu    loop()
                   (main.cpp:206)  (entry:    (entry:     (main.cpp:238)
                                   FIRMWARE   cpu_core.h:
                                   .ino:123)  84)

Loop Iteration     [See detailed   run_gpu()  run_gpu()   wifi_monitor_loop()
Operations         ops in Part 1]  × 4 unroll× 4 unroll  ArduinoOTA.handle()
                                   per       per         ring_buffer_check()
                                   iteration iteration   audio_pipeline_once()
                                                         pattern_draw()
                                                         LED_transmit()

Target FPS         120+ (line 214) 200+       100+        200+ (line 236)
                   (comment)       (unthrottl(matched     (comment)
                                   ed)        to audio)

Measured FPS       frame_count     FPS_GPU    FPS_GPU     watch_cpu_fps()
Calculation        over 5 sec      variable  variable    variable
                   (line 232)

Throttling         None            None      None        Conditional
                   (line 214)                            (ring buffer stub)

Loop Unroll        No              Yes: ×4   Yes: ×4     No
                                   (FIRM     (cpu_core.h
                                   WARE.ino) :88-90)

================================================================================
4. AUDIO/VIDEO SYNCHRONIZATION DETAIL
================================================================================

Sensory Bridge
  Model:           Atomic sequential execution
  Mechanism:       Audio + rendering in same loop iteration, same thread
  Ordering:        acquire_audio() → process_audio() → render() → LED_output()
  Per-Frame Audio: Exactly 1 chunk per visual frame
  Drift:           None (deterministic)
  Latency:         1 chunk (8ms) + 1 frame (8.3ms @ 120 FPS) = ~16ms
  Lock-Free:       Yes, atomic by design
  Critical Code:   main.cpp:271 (acquire_sample_chunk call in loop)

ESv1.2
  Model:           Independent cores with volatile handoff flags
  Mechanism:       Core 1 writes to sample_history[], flags when ready
                   Core 0 reads sample_history[] when flag set
  Flags:           waveform_locked (during shift)
                   waveform_sync_flag (new data ready)
  Ordering:        Core 1: read_audio → shift_history → set_flag
                   Core 0: read_flag → use_sample_history
  Per-Frame Audio: ~1.0 (can drift if GPU much faster than audio)
  Drift:           Possible (GPU @ 200 Hz, Audio @ 200 Hz = stable)
  Latency:         1 chunk (5ms) + 1 GPU frame (~5ms) = ~10ms
  Lock-Free:       Yes, volatile + single-writer (Core 1)
  Critical Code:   microphone.h:177-185 (lock/unlock during shift)

ESv2.0
  Model:           Independent cores with history buffers
  Mechanism:       Core 1 updates sample_history[] + half_rate[]
                   Core 0 reads from updated buffers
  Flags:           Not explicitly visible in excerpts (likely volatile)
  Ordering:        Core 1: read_audio → downsample → shift → implicit flag
                   Core 0: read from buffers every frame
  Per-Frame Audio: ~1.0 (matched because GPU slowed to ~100 Hz like audio)
  Drift:           Minimal (GPU paced to audio rate implicitly)
  Latency:         1 chunk (10ms) + 1 GPU frame (~10ms) = ~20ms
  Lock-Free:       Yes, single-writer (Core 1)
  Critical Code:   microphone.h:120-124 (shift_and_copy dual buffers)

K1.reinvented
  Model:           Atomic sequential + ring buffer stub
  Mechanism:       ring_buffer_has_data() returns true (stub)
                   Audio runs if condition true; otherwise skipped
  Flags:           None (sequential)
  Ordering:        if (has_data): acquire_audio → process_audio → render
  Per-Frame Audio: 0 or 1 chunk (depends on stub, currently always 1)
  Drift:           None (single-core atomic)
  Latency:         1 chunk (8ms) + 1 frame (5ms @ 200 FPS) = ~13ms
  Lock-Free:       Yes, atomic by design
  Critical Code:   main.cpp:247-249 (conditional ring buffer stub)

================================================================================
5. OPTIMIZATION TECHNIQUES OBSERVED
================================================================================

Loop Unrolling
  ESv1.2 (gpu_core.h:126-129):  run_gpu() × 4 per iteration
  ESv2.0 (cpu_core.h:88-90):    run_cpu() × 4 per iteration
  Effect:                        Reduces branch overhead ~2-3%
  Trade-off:                     Larger code, higher I-cache pressure

Downsampling
  ESv2.0 only (microphone.h:74-125)
  Method:                        Box filter (average adjacent samples) + SIMD divide
  Purpose:                       Reduce Goertzel processing load
  Result:                        Dual buffers at 12.8 kHz (full) + 6.4 kHz (processed)

SIMD Operations
  ESv2.0 (microphone.h:84, 111, 114):
    dsps_mulc_f32(): SIMD multiply-constant
    dsps_memset_aes3(): SIMD zero-fill
  Purpose:                       Optimize audio normalization

Profiling Integration
  ESv2.0 only: profile_function() wrapper in acquire_sample_chunk()
  Location:                      microphone.h:88, 125
  Purpose:                       Measure actual execution time

================================================================================
6. SAMPLE RATE STRATEGIC CHOICES
================================================================================

16 kHz (Sensory Bridge, K1.reinvented)
  Reasoning:         Standard speech bandwidth (8 kHz Nyquist)
  Pros:              Well-established, sufficient for music features
  Cons:              Loses HF content above 8 kHz

25.6 kHz (ESv1.2)
  Reasoning:         Maximize Nyquist frequency (12.8 kHz) for detail
  Pros:              Captures more musical content
  Cons:              Higher CPU load, more memory

12.8 kHz (ESv2.0)
  Reasoning:         Minimize processing, maximize efficiency
  Pros:              Lowest CPU cost + downsampling flexibility
  Cons:              Lowest frequency resolution (6.4 kHz Nyquist)

================================================================================
7. ERROR HANDLING & ROBUSTNESS
================================================================================

Sensory Bridge
  I2S Error Check:   NO (assumes always succeeds)
  Microphone Timeout: NO recovery mechanism visible
  Graceful Degradation: NONE

ESv1.2
  I2S Error Check:   NO (assumes always succeeds)
  Microphone Timeout: NO recovery mechanism visible
  Graceful Degradation: Conditional EMOTISCOPE_ACTIVE check (standby mode)

ESv2.0
  I2S Error Check:   NO (assumes always succeeds)
  Microphone Timeout: NO recovery mechanism visible
  Graceful Degradation: Conditional EMOTISCOPE_ACTIVE check (standby mode)

K1.reinvented
  I2S Error Check:   YES (microphone.h:98)
  Return Code Check: if (i2s_result != ESP_OK)
  Microphone Timeout: Zero-fill on error
  Logging:           Every 10th error to reduce spam
  Graceful Degradation: EXCELLENT (uses silence, continues)

================================================================================
8. LATENCY SUMMARY (Microphone to LED Output)
================================================================================

Sensory Bridge
  Audio chunk:       8 ms
  GPU frame:         8.3 ms @ 120 FPS
  Total:             ~16.3 ms
  Variability:       None (deterministic)

ESv1.2
  Audio chunk:       5 ms
  GPU frame:         5 ms @ 200 FPS
  Total:             ~10 ms
  Variability:       Low (can drift if GPU much faster)

ESv2.0
  Audio chunk:       10 ms
  GPU frame:         10 ms @ 100 FPS
  Total:             ~20 ms
  Variability:       Minimal (GPU paced near audio rate)

K1.reinvented
  Audio chunk:       8 ms
  GPU frame:         5 ms @ 200 FPS
  Total:             ~13 ms
  Variability:       None (deterministic, single-core)

================================================================================
9. RING BUFFER STATUS
================================================================================

Sensory Bridge
  Ring Buffer:       NO (direct state update)
  Pattern:           Sequential execution, no queueing
  Design:            Simple, correct, sufficient for performance

ESv1.2
  Ring Buffer:       NO (history buffer + volatile flags)
  Pattern:           Dual-core read/write to sample_history[]
  Design:            Lock-free but not formally a ring buffer

ESv2.0
  Ring Buffer:       NO (dual history buffers + implicit flags)
  Pattern:           Dual-core read/write to sample_history[] + half_rate[]
  Design:            Lock-free but not formally a ring buffer

K1.reinvented
  Ring Buffer:       PLANNED (main.cpp:229 TODO comment)
  Current:           STUB (ring_buffer_has_data() always returns true)
  Implementation:    MISSING (no actual ring buffer code present)
  Status:            Functional workaround using stub

================================================================================
10. ARCHITECTURAL DESIGN PHILOSOPHY
================================================================================

Sensory Bridge Philosophy
  "Single-core simplicity: everything sequential in main loop"
  Pros:  No synchronization complexity, atomic operations
  Cons:  Render loop can be blocked by expensive audio processing

ESv1.2 Philosophy
  "Parallel is faster: dedicate Core 1 to audio, Core 0 to video"
  Pros:  GPU never blocks on audio, supports 200+ FPS
  Cons:  Volatile flag handoff, possible frame drift, complex debugging

ESv2.0 Philosophy
  "Efficiency-first: slow down GPU to match audio, reduce power"
  Pros:  Minimal drift, lower power, simpler tuning
  Cons:  Capped at ~100 FPS, higher latency

K1.reinvented Philosophy
  "Sensory Bridge + planned async: start simple, upgrade to ring buffer"
  Pros:  Same safety as Sensory Bridge, clearer intent with ring buffer design
  Cons:  Ring buffer not yet implemented (stub only)

================================================================================
11. DECISION TREE: WHICH PATTERN TO USE?
================================================================================

Is rendering expensive (>10% of frame time)?
  NO  → Use Single-Core Sequential (Sensory Bridge / K1 approach)
        - Simpler, fewer bugs, deterministic latency
        - Sufficient for 120+ FPS with light patterns

  YES → Use Dual-Core Parallel (ESv1.2 / ESv2.0 approach)
        - Prevents render stalling on audio processing
        - Requires volatile flag synchronization
        - Monitor for frame drift (compare GPU and audio FPS)

Is latency critical (must be <15ms)?
  YES → Maximize sample rate + minimize chunk size
        - Use 25.6 kHz (ESv1.2 approach)
        - Accept higher CPU cost

  NO  → Optimize for efficiency
        - Use 12.8 kHz with downsampling (ESv2.0 approach)
        - Reduce CPU burden

Do you need robust error recovery?
  YES → Implement I2S error checking + zero-fill fallback (K1 approach)
        - Prevents hard crashes on microphone timeout

  NO  → Assume I2S always succeeds (Emotiscope approach)
        - Simpler code, works fine in lab conditions

================================================================================
FORENSIC INVESTIGATION COMPLETE
Examiner: SUPREME Analyst
Confidence Level: HIGH
Evidence Examined: ~65% of source code across all four implementations
Critical Gaps: LED timing, pattern rendering cost, actual FPS profiling
================================================================================

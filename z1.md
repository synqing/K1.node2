# K1 Control App Stabilization & Node Editor Integration

## Context: Current Situation

### User's Assessment

The K1 Control App (`k1-control-app/`) is currently **100% broken and unfit for purpose** due to multiple agents implementing code changes without respecting dependencies or downstream effects.

**Key constraints:**
- We don't need to start from scratch—we have the original Figma wireframe prototype
- We've learned significantly more about the project since initial design
- The original wireframe doesn't account for the Node UI integration
- Current UI design is fragmented across multiple iterations

### Strategic Pivot

Rather than patch the broken app, we will:

1. **Consolidate UI/UX requirements** based on learnings from the broken implementation
2. **Leverage Figma Make Agent** to design a new, cohesive wireframe
3. **Integrate the Node Graph Editor** as a first-class feature, not an afterthought
4. **Migrate incrementally** into the new design with strong guardrails

---

## Part 1: App Design & Figma Brief

### New App Information Architecture (IA)

#### Global Navigation Structure

```
Root Navigation
├── Dashboard
│   └── Device overview, connection status, quick actions
├── Control Panel
│   └── Effect selection, parameter sliders, color management, presets
├── Node Graph Editor
│   └── Canvas, node palette, inspector, compile/deploy pipeline
├── Profiling & Monitoring
│   └── Metrics, telemetry, performance plots, logs
├── Device Settings
│   └── Network, firmware, ports, advanced configuration
└── Discovery & Connect
    └── IP/serial, auto-discovery modal, connection health
```

#### Cross-Cutting Concerns

- **Device Context Provider**: Persistent device connection state available across all routes
- **Design Tokens**: Unified color scales, spacing, typography, elevation applied globally
- **Status/Notifications Layer**: Centralized toasts, banners, and error handling
- **Route-Based Code Splitting**: Heavy canvases (Node Editor) lazy-loaded to minimize bundle

---

### Node Graph Editor Page Design

#### Canvas Area

- **Pan/Zoom**: Smooth navigation with keyboard shortcuts
- **Grid Snapping**: Aligned placement of nodes
- **Multi-Select**: Select multiple nodes; group and layer control
- **Mini-Map**: Overview navigation for large graphs

#### Node Palette (Left Side)

```
Node Categories
├── Generators
│   ├── position_gradient
│   ├── time
│   └── random
├── Transforms
│   ├── sine_wave
│   ├── multiply
│   ├── add
│   └── clamp
├── Color Operations
│   ├── palette_interpolate
│   ├── hsv_to_rgb
│   └── gradient
├── Audio Nodes
│   ├── spectrum_bin
│   ├── spectrum_interpolate
│   └── chromagram
└── Compositors
    └── layer, output
```

**Palette Features:**
- Searchable by name or category
- Short descriptions and preview icons
- Example parameter presets for common use cases

#### Inspector Panel (Right Side)

- **Parameter Editing**: Typed inputs (numbers, ranges, colors, enums)
- **Live Preview**: Mock visualization of node subgraph when feasible
- **Validation**: Real-time error checking as user builds graph

#### Graph Pipeline Panel (Bottom)

```
Build Pipeline
├── Validate Graph → syntax, cycle detection, type checking
├── Compile to C++ → generate templates
├── Build Firmware → ESP32-S3 binary
└── Deploy to Device → OTA or serial upload
```

**Features:**
- Async progress tracking
- Build logs and artifact links
- Retry/rollback controls

#### Integration Hooks

| Action | Effect |
|--------|--------|
| **Apply Effect** | Send compiled artifact to Control Panel for runtime selection |
| **Save Pattern** | Store graph JSON + metadata for versioning and recall |
| **Benchmark** | Trigger profiling route with selected graph |
| **Export** | Download graph JSON or compiled binary |

---

### Figma Make Agent Brief

#### Design Goals

Produce a **wireframe + component system** for the Control App with integrated Node Editor that:
- Reflects evolved functions and layouts (not just applying old template)
- Prioritizes clarity and speed for a technical audience
- Enables incremental, story-driven implementation

#### Design System Deliverables

**Design Tokens**
- Color: dark theme with semantic scales (primary, success, error, warning)
- Spacing: standardized scale (4px, 8px, 12px, 16px, 24px, etc.)
- Typography: font family, sizes, weights, line heights
- Radius: corner radius scales for different component types
- Shadows: elevation levels for depth

**Component Primitives**
- Layout: sidebar, header, main, panels
- Interaction: tabs, cards, sliders with value chips, color pickers/palettes
- Data: tables, lists, grids
- Feedback: modals, toasts, loaders, error states
- Canvas: nodes, edges, ports, handles, context menus, mini-map, grid

#### Layout & Navigation Specifications

**Header**
- Device status indicator (connected/disconnected)
- Current effect/pattern name
- FPS counter or performance indicator
- Quick settings button

**Left Sidebar (Primary Navigation)**
- Navigation items: Dashboard, Control Panel, Node Editor, Profiling, Settings, Discovery
- Active state highlighting
- Collapse/expand behavior

**Control Panel (Main View)**
- Three-column layout matching "golden" reference screenshot:
  1. **Effect Selector**: Card grid of 9 effects with hover/selected states
  2. **Parameters**: Dynamic sliders, toggles, dropdowns per effect
  3. **Color Management**: Palette grid, brightness/blur controls

**Node Editor (Full View)**
- Full-bleed canvas (no chrome except mini-map)
- Right sidebar inspector (parameter editing, validation)
- Bottom pipeline status bar
- Context menu on right-click (add node, delete, align, etc.)

#### Key User Flows

```
Flow 1: Device Discovery & Connection
├── Launch app → Discovery modal
├── Enter IP or select from scan results
├── Verify connection → show status
└── Proceed to Control Panel

Flow 2: Control Panel Usage (Runtime)
├── Select effect card
├── Adjust parameters with sliders
├── Pick colors from palette
├── View real-time device rendering
└── Save as preset

Flow 3: Node Editor Usage (Design)
├── Open Node Editor
├── Drag nodes from palette onto canvas
├── Connect node outputs to inputs
├── Adjust parameters in inspector
├── Validate graph (check for errors)
├── Compile to C++ + build firmware
├── Deploy to device
└── Test in Control Panel, iterate

Flow 4: Profiling & Optimization
├── Select graph from history
├── Run benchmark
├── View FPS, memory, execution time charts
├── Identify bottlenecks
└── Return to Node Editor for optimization
```

#### Interaction & Behavior Specifications

**Node Editor Interactions**
- **Drag to canvas**: Create node at cursor
- **Click output port**: Start connection
- **Drag connection to input**: Complete wire
- **Right-click node**: Context menu (delete, duplicate, align, group)
- **Ctrl+Z / Cmd+Z**: Undo
- **Ctrl+Y / Cmd+Y**: Redo
- **Ctrl+A / Cmd+A**: Select all
- **Delete key**: Remove selected
- **Arrow keys**: Fine-tune position (hold Shift for larger steps)

**Parameter Controls**
- **Slider**: Constrained range with min/max labels
- **Text input**: Support for expressions (e.g., `Math.PI * 2`)
- **Color picker**: Dropdown with palette + manual RGB/HSV entry
- **Enum dropdown**: Fixed set of options

**Visual States**
- Default (idle), Hover, Focused, Disabled, Error
- Node states: idle, selected, dragging, highlighted (when parameter changes)
- Connection states: valid (green), invalid (red), pending (gray)

#### Accessibility Requirements

- **Color Contrast**: WCAG AA minimum (4.5:1 for text, 3:1 for UI components)
- **Focus Indicators**: Visible outline on all interactive elements
- **Keyboard Operability**: Canvas controls accessible via keyboard (arrow keys, Tab, Enter, Esc)
- **Labels**: All inputs have associated labels or aria-labels
- **Status Messages**: Build errors, validation messages announced to screen readers

#### Acceptance Criteria

- ✅ All screen wireframes reflect current Control Panel layout + integrated Node Editor
- ✅ Each screen has measurable UI elements and testable states (empty, loading, error, success)
- ✅ Design tokens documented in a system page with color swatches, spacing scale, typography scale
- ✅ Component variants shown for each primitive (button, input, slider, etc. in default/hover/focus/disabled/error)
- ✅ Interaction annotations explain drag-drop, pan-zoom, parameter editing
- ✅ Node palette categorization aligns with NODE_ARCHITECTURE.md
- ✅ Build pipeline panel shows 4 stages with success/error states
- ✅ Accessibility checklist completed (color contrast, focus states, keyboard shortcuts documented)

---

## Part 2: Stabilization & Implementation Plan

### Phase 0: Freeze & Inventory (1–2 days)

1. **Code Freeze**: No feature work on k1-control-app until new wireframe approved
2. **Environment Parity**: Standardize Node 20.x LTS, npm, Vite, React versions
3. **Golden Baseline**: Document "what it should look like" from your reference screenshot
4. **Error Inventory**: List all TypeScript errors, failing tests, console errors on dev startup

### Phase 1: Guardrails & CI Gates (2–3 days)

1. **CODEOWNERS** file: Require review for `k1-control-app/src/**/*` and `k1-control-app/styles/**/*`
2. **Branch Protection**: No direct pushes to main; require PR + status checks
3. **PR Template**: Checkboxes for "Touched global styles?", "Changed providers?", "Architectural change?"
4. **Test Scripts**:
   - `npm --prefix k1-control-app run test:rtl` → RTL component tests only
   - `npm --prefix k1-control-app run test:msw` → MSW integration tests only
   - `npm --prefix k1-control-app run test:e2e:smoke` → Load app, render key screens, verify no blocking errors

### Phase 2: New Wireframe & Shell (3–5 days)

1. **Figma Make Agent Brief**: Handed to architect; expect wireframe + system in 2–3 days
2. **New App Shell**: Create new routes/layout structure aligned to wireframe (don't modify broken app)
3. **Component Library**: Scaffold Storybook stories for new design tokens and primitives
4. **Node Editor Module**: Stub out routes, state shape, and data flow

### Phase 3: Incremental Migration (2+ weeks)

1. **Screen by Screen**: Port Control Panel (good reference), then Node Editor, then Dashboard
2. **Test Gate per Screen**: RTL + E2E smoke must pass before screen goes live
3. **Visual Regression**: Playwright snapshots vs. wireframe on each screen
4. **Parallel Fallback**: Keep old app accessible until new screens are validated

### Phase 4: Full Cutover & Hardening (1+ week)

1. **Retire Old App**: Remove broken screens once all functionality migrated
2. **Extended Testing**: Full RTL + MSW + cross-browser Playwright suite
3. **Performance Baseline**: Measure FPS, bundle size, load time vs. acceptance criteria
4. **Documentation**: Update DESIGN_SPECS.md with new component library, tokens, flows

---

### Governance & Guardrails

#### CODEOWNERS

```
# k1-control-app ownership
k1-control-app/src/**/* @spectrasynq
k1-control-app/styles/**/* @spectrasynq
k1-control-app/playwright.config.ts @spectrasynq
```

#### PR Template Checklist

```markdown
## Description
Brief summary of changes.

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Refactor
- [ ] Documentation

## Checklist
- [ ] Code follows style guide
- [ ] Tests added/updated
- [ ] Touched global styles? (if yes, link to ADR)
- [ ] Changed provider/context? (if yes, link to ADR)
- [ ] Added or modified routes? (if yes, link to ADR)
- [ ] Architectural change? (if yes, create ADR draft and link)
- [ ] Screenshots attached (UI changes)
- [ ] Artifact links included (test results)

## Test Results
- Type-check: PASS/FAIL
- RTL tests: N passed, M failed
- E2E smoke: PASS/FAIL
```

#### ADR Triggers

Create an Architecture Decision Record if your change:
- Adds or modifies routes
- Changes a provider or context
- Alters global styles or design tokens
- Adds a new major dependency
- Affects how Node Editor integrates with Control Panel

---

### Testing Strategy

#### Fast Path (Every PR)

1. Type-check (tsc)
2. RTL subset (components, hooks, utilities only)
3. E2E smoke (app loads, Control Panel renders, key elements present, no blocking errors)

**Expected time**: 2–3 minutes

#### Nightly Extended

1. Full Vitest (RTL + MSW integration)
2. Cross-browser Playwright (Chrome, Firefox, Safari)
3. Visual regression vs. Figma wireframe snapshots
4. Performance benchmarks (optional until baseline stable)

**Expected time**: 10–15 minutes

#### Before Cutover

1. Acceptance testing checklist per screen
2. Accessibility audit (WCAG AA)
3. Bundle size check (vs. baseline)
4. Production build validation

---

## Implementation Checklist

- [ ] **Figma Brief**: Draft document with IA, design system, flows, acceptance criteria
- [ ] **App IA Map**: Routes, components, data flow diagram
- [ ] **Guardrails**:
  - [ ] CODEOWNERS file in root
  - [ ] PR template added to `.github/`
  - [ ] Branch protections enabled on main
- [ ] **Test Scripts**:
  - [ ] `test:rtl` script added to k1-control-app/package.json
  - [ ] `test:msw` script added
  - [ ] CI updated to run `test:rtl` on PR
- [ ] **New App Shell**:
  - [ ] Routes created (Dashboard, Control Panel, Node Editor, etc.)
  - [ ] Layout scaffolded
  - [ ] Storybook setup with design tokens
- [ ] **Node Editor Feature**:
  - [ ] State shape defined (nodes, edges, selected, etc.)
  - [ ] Canvas component stubbed (d3 or React Flow decision)
  - [ ] Node palette components created
  - [ ] Inspector panel scaffolded
- [ ] **Migration Per Screen**:
  - [ ] Design wireframe reviewed
  - [ ] Components built in Storybook
  - [ ] RTL tests written and passing
  - [ ] E2E smoke passing
  - [ ] Screenshots match wireframe
  - [ ] Accessibility audit passed

---

## Decision Points

Before proceeding, confirm:

1. **Figma Make Capacity**: Can we hand off the brief in the next 24–48 hours?
2. **Node LTS Target**: Confirm Node 20.x as minimum?
3. **Package Manager**: npm only, or support pnpm/yarn?
4. **Canvas Library for Node Editor**: React Flow, d3, or custom?
5. **Visual Baseline Tech**: Playwright snapshots vs. managed service (Chromatic)?
6. **Design Token Implementation**: CSS variables, Tailwind, or styled-components?
7. **Timeline**: How many weeks until new app must be live?

---

## Next Actions

1. **Review this plan** and provide feedback
2. **Approve Figma Make brief** so architect can begin wireframe
3. **Confirm decisions** above
4. **I will then deliver**:
   - Formal Figma brief document (detailed, ready to hand off)
   - App IA and route map
   - CODEOWNERS and PR template files
   - New app shell scaffold with routes and layout
   - Storybook setup with design tokens and component primitives
   - Node Editor feature module stub
   - Migration checklist (screen by screen)

**This approach avoids wasted effort on the broken app and creates a clear path to a cohesive, maintainable control interface with integrated node editor.**
